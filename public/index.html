<!DOCTYPE html>
<html lang="en-us" dir="ltr" class="fancy">
<head>
    <meta charset="utf-8">
    <title>CMPT 328 — Activity 3.x</title>
    <link rel="stylesheet" type="text/css" href="homework.css">
</head>

<body>

<nav>
    <ul class="problem-links"></ul>
    <div class="icon"></div>
</nav>

<main class="justified">
    <div class="assignment-info">
        <h1>CMPT 328 — Activity 3.x</h1>

        <p>
            <a href="https://en.wikipedia.org/wiki/Seven-segment_display">Seven-segment displays</a> are used in some simple electronics (such as microwaves, digital clocks, etc.), frequently to show lengths of time and such. For example, below is a seven-segment display showing the digit 7:
        </p>
        <p class="centered">
            <img src="seven-segment-display-7.png">
        </p>

        <p>
            In a seven-segment display component, there are seven input wires, each controlling whether one of the seven segments is illuminated. Your task in this activity is to determine a Boolean function for each of those seven input wires so that the display correctly shows each of the 10 digits, 0 through 9.
        </p>

        <p class="centered">
            <img src="seven-segment-display-adapter.png">
        </p>

        <p>
            Specifically, you will have four Boolean inputs representing the four bits of the number (0000 for 0 through 1001 for 9). Using those, you will construct seven Boolean functions, one for each segment of the display, so that the display shows each digit correctly.
        </p>

        <div class="total points"></div>
    </div>

    <div class="problems">
        <div class="problem">
            <div class="title">Truth table</div>

            <p>
                Start by filling out a truth table for what the seven-segment display should show for each digit. In this table, the four inputs (w, x, y, and z) are the four bits of the number — for example, the number 5 (0101 in binary) would be the row w=0, x=1, y=0, z=1. The seven outputs each represent one of the segments (labeled a through g) of the seven-segment display. The truth table has only 10 rows because these are the only rows we care about: it is assumed that we will never be passed a value greater than 9. (In other words, the omitted six rows would all be “don’t-cares.”)
            </p>

            <p>
                Experiment with filling in the truth table and seeing which segments get illuminated as you put in ones. (Blanks are the same as zeros for purposes of this table.) Once you get the hang of it, work with your team on filling in the truth table until you are all satisfied with how each digit is displayed.
            </p>

            <div id="react-truth-table-segments"></div>

            <div class="total points">20 points</div>
        </div>

        <div class="problem">
            <div class="title">Boolean functions</div>

            <p>
                Now that you have a truth table for all seven segments, write Boolean functions to control each of the seven segments. These correspond to what circuitry would be connected to each of the seven-segment display’s seven inputs, and each can use the variables w, x, y, and z, being the four bits of the digit to display.
            </p>

            <p>
                For each of the seven segments, decide as a team whether it would be better to use SoP <code>_ _ _ + _ _ _ + _ _ _</code> or PoS <code>(_ + _ + _)(_ + _ + _)(_ + _ + _)</code> form, then write a function implementing the truth table you filled in above. Don’t worry about Karnaugh mapping it just yet; that’s the next step!
            </p>

            <div id="react-boolean-functions"></div>

            <div class="total points">20 points</div>
        </div>

        <div class="problem">
            <div class="title">Optimization</div>

            <p>
                Use Karnaugh maps to derive <em>optimal</em> SoP or PoS functions, using as few logic gates (and hence transistors) as possible. Fill in the table below, which will show you how many transistors are used in total by your functions.
            </p>

            <p>
                Since we don’t care what the seven-segment display would do for inputs greater than 9, you can (and should!) treat the six rows of the truth table corresponding to 10–16 as “don’t-care” values, allowed to be either 0 or 1, which can allow you to produce better (simpler) functions.
            </p>

            <div id="react-optimal-functions"></div>

            <div class="total points">20 points</div>
        </div>
    </div>
</main>

<script>
    "use strict";

    (function() {
        function isPlainMode() {
            if (window.location.search) {
                const params = new URLSearchParams(window.location.search);
                if (params.has("plain"))
                    return true;
            }

            return false;
        }

        function slugify(s) {
            let slug = "";
            for (let i = 0; i < s.length; ++i) {
                const c = s[i];
                if ("A" <= c && c <= "Z"
                    || "a" <= c && c <= "z"
                    || "0" <= c && c <= "9"
                    || c === "_" || c === "-")
                    slug += c;
                else
                    slug += "_";
            }

            return slug;
        }

        const plain_mode = isPlainMode();

        if (plain_mode)
            document.querySelector("html").classList.remove("fancy");

        // Insert an anchor before each problem, and if there is a problem links ul,
        // add a link to it
        const problem_titles = document.querySelectorAll(".problems > .problem > .title");
        const nav_ul = document.querySelector("ul.problem-links");
        let problem_number = 0;
        for (let i = 0; i < problem_titles.length; ++i) {
            const problem_title = problem_titles[i];
            let link_text = undefined;
            let anchor_name = undefined;

            if (problem_title.classList.contains("auto-number")) {
                ++problem_number;
                link_text = "Problem " + problem_number;
                anchor_name = "p" + problem_number;
                problem_title.innerText = "" + problem_number;
            } else {
                link_text = problem_title.innerText.trim() || undefined;
                anchor_name = slugify(link_text);
            }

            if (link_text && anchor_name) {
                const anchor = document.createElement("a");
                anchor.setAttribute("name", anchor_name);
                problem_title.parentElement.parentElement.insertBefore(anchor, problem_title.parentElement);

                if (nav_ul) {
                    const li = document.createElement("li");
                    const link = document.createElement("a");
                    link.setAttribute("href", "#" + anchor_name);
                    link.setAttribute("target", "_self");
                    const text = document.createTextNode(link_text);
                    link.appendChild(text);
                    li.appendChild(link);
                    nav_ul.appendChild(li);
                }
            }
        }

        // Watch document scrolls and highlight the link to the current
        // problem
        const problems = document.querySelectorAll(".problems > .problem");

        // Since some problems don't have links, we need to keep track of the mapping between problem index and link index!
        const problem_link_index_map = [ 0 ];

        let link_index = 1;

        for (let problem of document.querySelectorAll(".problems > .problem")) {
            problem_link_index_map.push(link_index);
            if (problem.querySelector(".title"))
                ++link_index;
        }

        let current_tab = null;
        let current_problem = -1;

        function updateCurrent() {
            const viewportHeight = document.querySelector("html").clientHeight;
            let new_current_problem = -1;
            for (let i = problems.length - 1; i >= 0; --i) {
                const client_rect = problems[i].getBoundingClientRect();
                if (client_rect.top < viewportHeight * 0.3) {
                    new_current_problem = i;
                    break;
                }
            }

            if (new_current_problem === -1 && problems.length > 0)
                new_current_problem = 0;

            const tabs = document.querySelectorAll("nav ul li");
            if (new_current_problem !== current_problem) {
                if (current_tab !== null)
                    current_tab.classList.remove("current");
                if (new_current_problem !== -1) {
                    let tab_index = problem_link_index_map[new_current_problem];
                    if (tab_index >= tabs.length) {
                        tab_index = tabs.length - 1;
                    }
                    current_tab = tabs[tab_index];
                    current_tab.classList.add("current");
                } else
                    current_tab = null;

                current_problem = new_current_problem;
            }
        }

        if (nav_ul) {
            document.addEventListener("scroll", updateCurrent);
            updateCurrent();
        }

        for (let problem of problems) {
            const total_points = problem.querySelector(".total.points");
            const points = problem.querySelectorAll(".points:not(.total)");

            if (!total_points)
                continue;

            let sum = 0;
            for (let point of points) {
                const value = parseInt(point.innerText);
                if (!isNaN(value)) {
                    sum += value;
                    if (!point.hasAttribute("title"))
                        point.setAttribute("title", value + (value === 1 ? " point" : " points"));
                }
            }

            if (total_points && total_points.innerText.trim() === "")
                total_points.innerText = sum + (sum === 1 ? " point" : " points");
        }


        const homework_total_points_box = document.querySelector(".assignment-info .total.points");
        if (homework_total_points_box) {
            let homework_total_points = 0;
            const points_pattern = /^\s*(\d+)\s+points?\s*$/i;
            for (let problem_total_points of document.querySelectorAll(".problem .total.points")) {
                const match = points_pattern.exec(problem_total_points.innerText);
                if (match)
                    homework_total_points += parseInt(match[1]);
            }

            homework_total_points_box.innerText = homework_total_points + (homework_total_points === 1 ? " point" : " points");
        }

        if (plain_mode) {
            let problem_counter = 1;
            for (let problem_title of document.querySelectorAll(".problems > .problem > .title")) {
                if (problem_title.classList.contains("auto-number")) {
                    problem_title.innerText = "Problem " + problem_counter;
                    ++problem_counter;
                }
            }

            for (let point of document.querySelectorAll(".problem .points:not(.total)")) {
                point.innerText = "(" + point.innerText + " points)";
            }
        }
    })();
</script>

</body>
</html>
